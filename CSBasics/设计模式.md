设计模式（Design Pattern）是一种被广泛接受的**代码设计经验的总结和归纳**，它提供了一套可重复使用的解决方案，用于解决在软件设计过程中所遇到的一些**常见问题**，从而提高代码的**可读性、可维护性和可扩展性**。

设计模式通常分为三类：创建型模式、结构型模式和行为型模式。下面分别介绍一下这三类模式以及一些常见的设计模式：

[设计模式总结一](https://refactoringguru.cn/design-patterns/bridge) 【重要】

[设计模式之菜鸟](https://www.runoob.com/design-pattern/bridge-pattern.html)

[设计模式之掘金](https://juejin.cn/collection/7248828229914312759)

#### 创建型模式

创建型模式关注如何实例化对象。常见的创建型模式有：

- 工厂模式（Factory Pattern）

  > 工厂模式是一种常用的对象创建设计模式，通过定义一个工厂接口来创建产品对象，而不是直接new产品对象

- 单例模式（Singleton Pattern）

  > 单例模式保证每个类只有一个实例，并提供全局访问点来访问这个实例
  >
  > 1. 全局唯一的系统配置
  > 2. 全局的日志对象

- 建造者模式（Builder Pattern）

  > 创建一个构造器来构造复杂的对象

- 原型模式（Prototype Pattern）

  > 不需要显式的通过构造函数利用现有的对象来构建新的对象

#### 结构型模式

结构型模式关注如何组合类和对象以形成更大的结构。常见的结构型模式有：

- 适配器模式（Adapter Pattern）

  > 将一个类的接口转化为另一个客户希望的接口
  >
  > 创建一个新的适配器类来继承原有的类实现新的接口
  >
  > 例如：==构建一个适配器将返回的是数据格式进行统一的处理==
  >
  > 1. 项目中页面有：下拉框、列表和多选框等，构建一个适配器将后端传回来的数据通过一个适配器进行统一处理得到想要的数据格式

- 桥接模式（Bridge Pattern）

  > 抽象部分与实现部分分离，例如GUI界面（抽象）和操作系统API（实现）

- 组合模式（Composite Pattern）

  > 同一个维度的对象像树一样组合在一起

- 装饰器模式（Decorator Pattern）

  > 在不修改对象自身的基础上，通过对其进行包装（装饰）来拓展其行为和功能的目的

- 外观模式（Facade Pattern）

  > 为复杂系统提供简单的接口

- 享元模式（Flyweight Pattern）

  > 通过共享对象来支持大量的细粒度对象，享元模式对象中分为内部状态和外部状态，内部对象独立于对象的上下文环境，可以被全局共享，外部对象取决于对象的上下文环境，无法共享

- 代理模式（Proxy Pattern）

  > 在访问对象时引入一定程度的间接性，以便更好地控制对对象的访问
  >
  > 1. 远程代理：在另外一个主机上创建该对象的本地代理
  > 2. 虚拟代理：充当对象的占位符，使用时再创建，例如浏览器图片加载
  > 3. 安全代理：安全代理用于控制访问资源的权限，例如对敏感对象采用代理方式

#### 行为型模式

行为型模式关注对象之间的通信。常见的行为型模式有：

- 责任链模式（Chain of Responsibility Pattern）

  > 允许请求沿着责任链发送

- 命令模式（Command Pattern）

  > 将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

- 解释器模式（Interpreter Pattern）

  > 定义中语言文法的表示，并定义一个解释器，用来解释这种语言的句子

- 迭代器模式（Iterator Pattern）

  > 提供一个简单的方法来访问一个聚合的对象（例如一个列表或者集合）的所有元素，无需了解底层的细节
  >
  > 1. 聚合对象：提供创建迭代器的接口（列表、集合等）
  > 2. 迭代器：定义了访问和遍历聚合对象中元素的接口

- 中介者模式（Mediator Pattern）

- 备忘录模式（Memento Pattern）

- 观察者模式（Observer Pattern）

  > 通过定义一对多的依赖关系，让多个观察对象同时监听某一个对象主题，当对象主题发生变的时候，所有观察者都会收到通知和更新

- 状态模式（State Pattern）

- 策略模式（Strategy Pattern）

  > 策略+上下文对象

- 模板方法模式（Template Method Pattern）

- 访问者模式（Visitor Pattern）

  > 主要目的是将算法和数据结构分离，即不改变数据结构的前提下，定义作用于这些结构上的新操作