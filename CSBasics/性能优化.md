### 网络请求与响应阶段

> 发送网络请求和响应请求

#### 问题

> 首字节时间过长

1. 重定向过多
2. DNS查询时间太长
3. TCP连接时间太长
4. 服务器距离远/性能差
5. 请求太多

#### 优化方法

1. 域名解析——DNS预解析
2. 服务器去距离和数量
   + 使用多个域名(2-4最佳)
   + 内容分发网络
3. 请求优化
   + 数量
     + 避免代码中同一个API多次请求
     + 缓存——对静态资源进行缓存
     + 避免图片中src为空——请求页面相对路径耗时
     + 按需加载
   + 速度
     + 压缩响应
       + 客户端Accept-Encoding标记压缩
       + 服务端Content-Encoding告知压缩方法
     + 图片优化——webp替代png等
     + 文件压缩
4. 其他
   + tcp/udp选择
   + tcp数据分片与慢启动

#### 工具——webpack

1. 打包优化
   + 模块解析规则配置——resolve质地感第三方库查找范围、指定文件后缀
   + 按需加载
     + 抽离css mini-css-etract-plugin
     + 拆分代码——打包过程将代码进行拆分,例如同步代码和异步代码等等
   + 代码压缩
     + terser-webpack-plugin 对js代码做压缩(v4版本uglify-webpack-plugin)
     + css-minimizer-webpack-plugin 对css压缩
     + htmlwebpackPlugin设置minfy，对代码进行压缩
     + compression-webpack-plugin 对文件进行压缩
     + image-webpack-loader 图片压缩
   + 去除死代码(tree shaking)——terser-webpack-plugin 
   + 代码分离
     + chunks对同步代码、异步代码还是全部代码进行处理
     + miniSize 设置每个拆分包的最小大小
     + maxSize 设置每个拆分包的最大大小 
2. 图片优化
   + css效果替代简单的渐变图片
   + webp替换png
   + 裁剪/压缩图片



### 解析与渲染阶段

> 解析HTML、构建DOM树

#### 问题

> DOM构建和首屏时间过长

1. 静态资源问题
   + 未合理的配置缓存
   + 未提前引入关键css
   + 未优先加载页面所有需要的关键图片和文件资源
2. 动态资源问题
   + 未对非关键的javascript脚本采用异步标记
   + 未对代码进行拆分(单个脚本太大)
   + css查询方式等问题
3. 代码问题
   + 没有实现按需加载
   + 内存没有在合适的时间释放
   + 没有采用懒加载(虚拟列表)

#### 优化方法

1. 客户端渲染慢
   + SSR服务端渲染

2. 静态资源问题
   + 对静态资源进行缓存
   + 提前引入页面所需要的关键资源

3. 动态资源问题
   + 采用webpack对打包代码进行拆分
   + 优化css选择器(减少规则匹配和多层嵌套)
   + 采用异步标记或者打包时进行异步拆分
   + script标签加上defer和async字段

4. 代码问题
   + 采用懒加载方式
   + 使用let和const,少用var
   + 减少频繁使用的对象(事件)的创建和删除
   + 使用模板、减少相同的html频繁使用(组件话——复用性强)

### 完全加载与更新阶段

> 框架层面的优化

#### 问题

> 更新缓慢

1. 频繁操作DOM
2. 更新加载数据过多
3. 重绘与重排
4. 事件处理

#### 优化方法

1. JS层面
   + 事件委托
   + 防抖与节流
2. 框架层面
   + React优化[查看react总结中的性能优化]
   + Vue优化
     + 路由懒加载
     + v-for添加key
     + 第三方插件按需引入
     + diff算法(复用)
     + 合理的使用computed和watch
     + destory销毁事件