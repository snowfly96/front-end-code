###  :pen: 基础问题 

JavaScript是一种脚本语言，用于给文档添加各种复杂的行为，使得各种静态网页变成具有交互功能的动态网页。在JavaScript中没有多线程的概念，js是单线程的，使用异步机制来处理各类事件。

#### 1. js由哪三部分组成？

> **ECMAScript：**js的核心，用于描述javascript的语法
> **文档对象模型：**将html页面抽象成为一棵逻辑树，树中每个节点代表一个元素，提供给js访问操作树对象的接口
> **浏览器的对象模型：**用于控制浏览器行为的接口

#### 2. js的内存管理方式？

> 分配内存=>释放内存
>
> 创建变量的时候根据变量类型在对应的栈和堆中分配内存
> 局部作用域内的变量在函数完毕自动释放，堆栈内的对象重新赋值给null或者程序运行结束，关闭浏览器的时候自动释放

#### 3. 什么是变量/函数提升？

> **变量声明提升**
>
> 1. 通过var声明定义的变量，在定义之前都会被访问到
> 2. 提升属于声明提升，值为undefined，后续再进行赋值
>
> **函数声明提升**
>
> 1. 通过function声明的函数，在其之前就可以调用
> 2. 值：定义的函数对象

#### 4. let，const与var的区别？

> let与var
>
> 1. 作用域不同：let是块级作用域变量，var方法作用域变量
> 2. var存在变量提升问题，let不存在变量提升问题
> 3. let不允许变量重复声明，未声明使用则会报错
>
> const
>
> 常量声明，变量必须初始化，后面不能再修改值（实际上指向的内存地址不能修改）
> const 声明的变量保存的只是**栈内存**中的地址

#### 5. 可枚举和可迭代？

> 1. **可枚举：**决定对象中的属性能否通过for in遍历到
> 2. **可迭代：**拥有next方法，通过迭代器进行元素的顺序遍历访问

#### 6. instanceof与typeof区别？

> **instanceof**
>
> 1. 使用方法：“xxx” instanceof String
> 2. 返回值：布尔值
>
> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
>
> **typeof**
>
> 1. 使用方法：typeof xxx 返回一个数据类型对象字符串
> 2. 不能区别：null和Object（“object”），Array和Object（“object”）
>
> 对null（object）无效，对function（function）有效

#### 7. null与undefined区别？

> **undefined**
>
> 1. undefined属于变量的生命，表示该变量后续会被使用，当下没有对其做任何操作
>
> **null**
>
> 1. 在声明变量的时候被赋值为null，为该变量占了一个坑，暗示即将被赋值为一个对象
> 2. 可以对不使用的对象进行内存回收

#### 8. 基本数据类型与引用数据类型赋值？

> **引用数据类型**
>
> 1. 采用引用方式，用别名的方式指向同一块内存空间
> 2. 每个引用变量都可以修改指向的对象的值
> 3. 当其中一个引用变量被赋值新的对象时，该引用变量与原内存空间断开连接，另外的引用变量不受影响
>
> **基本数据类型**
>
> 1. 基本数据类型采用赋值的方式，变量修改值互不影响

#### 9. 函数调用的方法？

> 1. func() 直接调用
> 2. obj.func() 对象调用
> 3. new func() new创建实例调用
> 4. func.call(obj)/func.apply(obj)：修改this指向调用

#### 10. 立即执行函数？IIFE

> immediately invoked function expression
>
> 1. 隐藏实现，不会污染外部命名空间
> 2. 可以向外暴露一个全局函数

#### 11. 静态语言与动态语言？

> **静态语言和动态语言？**
>
> 1. **静态语言：**编译时变量的数据类型就可以确定的语言（C++/java等）
> 2. **动态语言：**运行时才确定数据类型的语言，变量使用之前无序声明类型（js/python等）
>
> Facebook的Flow允许js的静态类型检查
>
> **静态优点：**
>
> 1. 早发现错误
> 2. 减少错误处理
> 3. 减少bug
>
> **静态缺点：**
>
> 1. 代码冗长
> 2. 需要花时间掌握类型

#### 12. 静态作用域与动态作用域？

> 静态作用域：词法阶段就已经确定了
> 动态作用域：在程序执行的时候确定的

#### 13. promise和async await的区别？

> 1. **promise** 是为了解决**回调地狱**，但链式调用的 promise 同样让**代码纵向发展造成了代码冗余**
> 2. ES6 出现了生成器， **generator** 做异步处理返回iterator，但通过 next 方法去执行异步处理的每一段，使得**代码不易阅读**
> 3. **async 函数是 generator 的语法糖**，用 async替换星号 ，用await替换yield； async 可以像普通函数一样执行且返回 promise 对象便于后续调用

#### 14. 类数组对象？

> 可以利用索引访问，并具有length属性的对象

#### 15. 原型与原型链？

> **万物皆对象**
>
> 1. 创建函数的时候，解析器会给函数添加一个prototype属性（显式原型），该属性默认指向一个空对象（**原型对象**）；
> 2. 利用构造函数构建的**实例对象**都可以通过__proto__属性（隐式原型）访问到构造函数的prototype属性；
>    也就是说构造函数的prototype和实例对象的__proto__指向的是同一个**原型对象**，该**原型对象**属于存放着构造函数的属性与方法，相当于一个公共的内存空间
> 3. **实例对象**也可以由自己的私有属性和方法，当实例对象在调用某个属性和方法的时候，在自己内部找不到，就会通过__proto__访问到其构造函数的**原型对象**，查看是否存在相应的属性和方法，如果没有，继续通过构造函数的原型对象的__proto__往上找，知道最后一个原型对像null，该过程构成原型链**实例对象的constructor方法指向构造函数**

#### 16. 闭包与闭包作用？

> **定义：**当一个嵌套的内部（子）函数引用外部（父）函数的变量，执行外部函数时就能产生闭包
> 可以通过浏览器的调试工具查看
>
> **理解一：**闭包是嵌套的内部函数
> **理解二：**闭包是被引用变量（函数）的对象
> **闭包的生命周期**
>
> 1. 产生：嵌套内部函数定义执行完毕之后就产生，不是调用时
> 2. 死亡：嵌套内部函数称为垃圾对象时，即外部的变量f=null不指向返回的闭包函数时
>
> **优点**
>
> 1. 使得变量在执行完后，仍然存在内存中（延长生命周期）
> 2. 使得外部函数可以操作函数内部变量（按特定方法，暴露操作接口，不暴露变量）
>
> **缺点**
>
> 1. 内存泄漏
> 2. 局部变量长时间占用内存，消耗内存资源
>
> **应用：定义JS模块**
>
> 1. 具有特定功能的模块
> 2. 将所有数据和功能封装在一个函数内部
> 3. 向外只暴露一些特定的函数/接口
> 4. 模块的使用者，只需要通过模块暴露的方法实现对应的功能

#### 17. 回调函数？

> **遵循原则：**
>
> 1. 自定义的函数
> 2. 自己没有调用
> 3. 最终被执行了
>
> **常见的回调函数：**
>
> 1. DOM事件回调
> 2. 定时器回调函数
> 3. ajax异步请求回调
> 4. 生命周期（钩子）函数回调

#### 18. js的this问题？

> **任何函数本质上都是通过某个对象调用的，**分为
>
> 1. 明确制定
> 2. 被动指定
>
> **this指向：**调用该函数的对象
>
> 1. 所有函数内部都有一个变量this
> 2. 它的值对应于调用对象
> 3. 不指定this则指向window

#### 19. 执行上下文问题？

> **代码分类**
>
> 1. 全局代码
> 2. 函数代码
>
> **全局执行上下文**
>
> 1. 执行全局代码之前将window确定为全局执行上下文对象
> 2. 对全局数据进行预处理
>    - 将var进行变量提升
>    - 将function进行变量提升
>    - 将this赋值该window
>
> **函数执行上下文**
>
> 1. 在调用函数，准备执行之前，创建一个函数上下文对象
> 2. 对局部变量进行预处理
>    - 形式参数->赋值给实际参数->添加到函数上下文
>    - var声明的变量提升，添加...
>    - function函数声明提升，添加...
>    - arguments赋值给实际参数列表，添加...
>    - this指向调用函数的对象
>
> **执行上下文栈**
>
> 1. 全局代码执行之前，JS引擎会创建一个栈来管理上下文对象
> 2. 全局执行上下文window确定后，添加到栈中
> 3. 函数执行上下文确定之后，添加到栈中
> 4. 最内层函数执行完毕之后，函数执行上下文依次出栈
> 5. 当所有代码执行完毕之后，全局执行上下文window对象出栈

#### 20. 作用域问题？

> 1. **执行上下文**是代码执行后产生的，属于动态的
> 2. **作用域**在编写代码的时候就确定了，属于静态的
>
> 隔离变量，不同作用域下的变量互不影响
> \------------
> var x=10;
>
> function fn(x) {console.log(x);}
> function show(f) {
>
> ​	var x=20
>
> ​	f()  }
>
> show(fn) // 输出10，代码执行前确定的

#### 21. js的异步机制？

> 采用一个执行栈和一个任务队列来完成异步操作，所有同步操作在主线程上进行执行，执行完成之后从任务队列中取出各种事件回调的异步任务进行执行

#### 22. 宏任务与微任务？

> 消息队列中的任务通常存储着宏任务，比如I/O，setTimeOut，setInterval等
>
> 微任务如：promise.then等

#### 23. js的内存泄漏情况？

> 1. 意外的全局变量
> 2. 闭包
> 3. 未被清空的定时器
> 4. 未被销毁的事件监听
> 5. DOM 引用

#### 24. js的单线程？

> js代码分为**初始化代码和回调代码**
> 回调代码放入分线程中，等初始化代码在主线程中执行完毕之后才通过消息队列和事件查询送到主线程中执行
>
> **事件循环模型**
>
> 1. 创建worker对象
> 2. 该方法存在不能访问DOM和部分浏览器不支持问题

#### 25. js的定时器？

> 定时器定时执行么？
>
> 1. 一般会延迟，也可能延迟较长时间
> 2. 需要了解JS的单线程机制和消息队列

#### 26. 防抖与节流？

> **防抖函数**
>
> 事件响应函数在一段时间后再执行，如果函数在这段时间再次被调用，计时器清零，重新计算执行时间 
>
> 防抖函数只会在高频事件结束后 n 毫秒调用一次函数
>
> 1. scroll滚动事件
> 2. 搜索框输入查询
> 3. 表单查询
> 4. 按钮提交
> 5. 浏览器缩放等
>
> **节流函数**
>
> 节流函数会在高频事件触发过程当中每隔 n 毫秒调用一次函数
>
> 1. mousemove事件
> 2. 搜索联想 
> 3. DOM的拖拽
> 4. 页面滚动与自动加载

#### 27. ajax的原理？

> **原理：在不加载整个网页的情况下，通过异步操作与服务器交换数据来更新页面内容**
> 通过XMLHttpRequest对象向服务器发送异步请求，然后从服务器上拿到数据，最后通过JS操作DOM更新页面
>
> 1. 创建XMLHttpRequest对象 xml
> 2. 通过xml中的open()方法与服务器建立连接
> 3. 构建请求所需要的数据，通过xml对象的send()方法发送给服务器
> 4. 通过xml对象的onreadystatechange事件监听服务器的和客户端通信状态
> 5. 接受并处理服务器响应的数据

#### 28. map与forEach的区别？

> **相同点**
>
> 1. 都是循环遍历数组中的每一项
> 2. 每次执行匿名函数都支持三个函数
> 3. 匿名函数中的this指向window
>
> **不同点**
>
> 1. map返回新数组
> 2. forEach运行callback更改原始数组

#### 29. 什么是可迭代对象？

> ES6新增语法for of，仅限于迭代器；可迭代的对象Array, Map, Set, String, TypedArray, arguments等
>
> for in 是遍历可枚举对象



#### 30. \==与===区别

> ==需要将左右两边的值转换为同一类型再进行比较
>
> + 会先判断是否在对比null 和undefined ，是的话就返回true.
> + 判断两者类型是否为string 和number，是的话就会将字符串**转换**为number.
>
> ===类型不同直接返回false
>
> false==‘’‘’返回true



#### 31. js的发布与订阅模式？chatgpt

> js的发布订阅模式是一种常见的事件处理机制，订阅者可以订阅某一个主题，并在主题有更新的时候接受通知
>
> 发布订阅步骤：
>
> 1. 定义主题：定义一个主题对象，并保存订阅者列表。主题对象可以提供订阅和取消订阅的方法。
> 2. 定义订阅者：定义一个订阅者对象，并实现 `update()` 方法来接收更新通知。
> 3. 创建主题和订阅者，并进行订阅
> 4. 发布更新：当主题有更新时，调用 `notifyObservers()` 方法通知所有订阅者。



#### 32. 观察者与被观察者？chatgpt

> 观察者模式（Observer Pattern）是一种常见的设计模式，也称为发布-订阅模式。该模式定义了一种一对多的关系，使得当一个对象的状态发生改变时，所有依赖它的对象都能够自动收到通知并进行相应的更新。
>
> 在 JavaScript 中，观察者模式的实现通常涉及两个主要角色：观察者和被观察者。被观察者维护一组观察者，并且提供添加、删除、通知观察者的方法。观察者则负责接收被观察者的通知，并进行相应的操作。



#### 33. js事件冒泡机制？chatgpt

> 事件冒泡（Event Bubbling）是指当一个元素上的事件被触发时，它会先被该元素自身处理，然后逐级向上传递给该元素的祖先元素，直到被文档中的根元素处理为止。这个过程就像气泡从水底逐渐上升到水面一样，因此称为“冒泡”。例如：
>
> <div id="outer">
> <div id="inner">
>  <button id="button">Click me</button>
> </div>
> </div>
>
>
> 如果点击按钮元素，点击事件会按照如下顺序触发：
>
> 1. `button` 元素触发点击事件。
> 2. 事件向父元素 `inner` 冒泡，触发 `inner` 的点击事件。
> 3. 事件继续向父元素 `outer` 冒泡，触发 `outer` 的点击事件。
> 4. 事件最终冒泡到文档对象，触发文档对象的点击事件。
>
> 在事件冒泡中，可以使用 `event.target` 属性来获取触发事件的元素，也可以使用 `event.currentTarget` 属性来获取当前正在处理事件的元素（即注册了事件监听器的元素）。可以通过在事件监听器中调用 `event.stopPropagation()` 方法来停止事件冒泡，即在当前元素上处理事件而不继续向上冒泡。
>
> ```js
> button.addEventListener("click",function (event) {
>   if (event.stopPropagation) {
>     event.stopPropagation()
>   }else{
>     event.cancelBubble=true
>   }
>   console.log("button click");
> })
> ```



#### 34. getUTCDate()和getDate()差别

> getUTCDate()返回Date全球标准时间的UTC表示的日期
>
> getDate()返回的是本地时间的表示的日期



#### 35. Event loop（事件循环）

> js引擎中，存在一个event loop事件循环机制来管理任务队列，其中包括宏任务队列、微任务队列、和事件循环队列
>
> **事件循环队列：**是浏览器或者node.js环境下的一种任务，用于存放事件，比如鼠标点击和键盘输入等，事件会在对应的dom元素上进行触发然后添加到事件队列中等待处理
>
> **宏任务队列：**用于存放主线程中执行的异步任务，包括定时器任务、i/o操作和ui渲染等；
>
> **微任务队列：**用于存放当前任务执行完毕之后立即执行的异步任务，包括promise回调、async/await等
>
> 事件循环队列可以看成一种特殊的宏任务队列，宏任务队列和事件循环队列没有绝对有执行顺序优先级
>
> js主线程总的来说，执行顺序是先执行宏任务，在执行微任务（宏任务和微任务的添加顺序是不一定的），**在执行完一个宏任务之后，会立即执行所有的微任务，然后再执行下一个宏任务**



#### 36. ECMAScript（ES6）规范、CommonJS规范和AMD规范区别

> ECMAScript规范事对js语言本身进行规范化，定一个了javascript的基本语法、数据类心和内置对象等。AMD和CommonJS规范主要是对js的模块化开发进行标准化，主要解决js的代码组织和管理；
>
> 1. AMD规范采用异步加载的模块的方式，使用require()函数加载模块，define函数定义（导出）模块；CommonJS规范采用同步加载模块的方式，使用require()函数加载模块，exports对象定义（导出）模块
>
> 2. AMD主要用于浏览器环境，CommonJS主要用于服务端js的开发，随着nodejs的流行，CommonJS规范也逐渐在浏览器端得到应用



#### 37. 模块化和编译构建

> 模块化是将代码根据应用的所需的不同功能划分为不同的模块，各个模块之间相互独立。这种低耦合高内聚的模块化方式可以帮助程序员更好的管理代码，负责不同模块的程序员可以只关系自己模块内部的实现，当需要用到别的模块的时候只需要调用其他模块的接口，不需要关心具体实现，提高了开发效率；除此之外，对代码进行模块化封装还可以提高代码的复用率。
> 编译构建是将高级语言编译成二进制可执行的文件的过程。在该过程不同模块会被链接组合到一起，形成一个完整的程序；例如C++在编译构建时会将不同库文件链接在一起，形成一个独立的可执行代码，前端同样在编译构建会将不同模块的js代码、html和css等资源打包压缩成一个文件，形成一个独立的文件。
>
> 模块化代码使得代码结构化和规范化，但是使得一个独立的程序形成了分散的模块，不同的分散的模块化则需要通过编译构建来进行整合和处理，并且编译构建的过程能够对模块化代码进行优化，使得代码体积和性能更好！模块化相当于是对一个独立程序解构，编译构建则是对解构后的模块进行重组！拆解和重构的过程形成的具有不同功能模块，便于团队协作和方便程序员的管理和维护代码，提高开发效率！



#### 继承

![image-20230729231705137](/Users/snowfly96/Documents/GitHub/front-end-code/JavaScript/面试/assets/image-20230729231705137.png)

#### 什么是字面量

> *字面量*是指由字母，数字等构成的字符串或者数值，它只能作为右值出现(等号右边的值）
>
> int a; //变量 
>
> const int b = 10; //b为常量，10为字面量 
>
> string str = “hello world！”; // str 为变量，hello world！为字面量



#### 什么是symbol

> 主要用来定义一个唯一的属性值，防止重复命名，再对象中有着重要的*作用*（作为对象的计算属性）
>
> symbol有一些方法来规定对象是否有某些属性，如symbol.iterator判断一个对象是否可迭代



#### arguments/this/callee/caller

> 使用 arguments.callee 就可以让函数逻辑与函数名解耦，指向 arguments 对象所在函数的
>
> 指针
>
> caller这个属性引用的是调用当前函数的函数



#### 代理与反射

> 用于监听目标对象的set和get的方法的调用情况
>
> 代理是由Proxy构造函数创建出来的一个代理对象，构造函数接收两个参数
>
> - target 目标对象（要操作的对象）
> - handler 处理程序对象（拦截后触发的捕获器api的集合对象）
>
> 目标对象可以直接调用，也可以通过代理对象进行调用，最终的操作结果也会反映到目标对象里面
>
> 代理之所以能够针对底层操作进行拦截并且能够进行额外的操作，就是通过**捕获器**来实现的
>
> 反射是含有13个方法的反射对象，将Object的一些命令式的操作转变成了函数式



#### created与mounted区别

> created：通常用于初始化某些属性值，例如data中的数据，然后再渲染成视图。
>
> mounted：通常在初始化页面完成后，对html的dom节点进行需要的操作



#### 强引用和弱引用

> [强引用和弱引用](https://www.qycn.com/xzx/article/6219.html)：只在weakSet和weakMap里面体现



#### async和await

> await等待的是一个new promise微任务，不等待settimeout宏任务对象
>
> ```js
> const taskRunner =  async () => {
> // await setTimeout(()=>{console.log("time");},1000);
> await new Promise((resolve,reject)=>{
>  setTimeout(()=>{
>    console.log("time")
>  },1000)
> })
> console.log("hello");
> }
> taskRunner()
> ```



#### JS的垃圾回收

> 标记清理：标记阶段和清除阶段，从根节点循环遍历所有的引用，标记所用的引用对象，为标记的对象被认为垃圾对象，在清除阶段垃圾回收器遍历整个内存空间，将所有的未标记的对象进行清除，释放内存空间
>
> 引用计数：引用一次+1，减少一次引用-1，引用为0，释放



#### JS编译过程

> 1. 词法分析
> 2. 语法分析
> 3. 抽象语法树
> 4. 机器指令



#### 请求拦截器与响应拦截器

> **请求拦截器**
>
> 请求发送之前进行一些操作，例如在每个请求头里面加上token（统计处理更加方便）
>
> **响应拦截器**
>
> 在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录时候，跳转到登录页面



#### Js的toString方法

> `toString()`是一个内置方法，可以将一个对象转换为字符串表示形式。当调用该方法时，它将返回该对象的字符串表示形式。
>
> 大多数JavaScript对象，`toString()`方法返回的是对象类型和内存地址的字符串表示形式

```js
let obj = {};
console.log(obj.toString()); // [object Object]

let arr = [1, 2, 3];
console.log(arr.toString()); // 1,2,3

let num = 42;
console.log(num.toString()); // 42

let bool = true;
console.log(bool.toString()); // true
```

重写toString方法

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.toString = function() {
  return `Person { name: ${this.name}, age: ${this.age} }`;
};

let person = new Person("John", 30);
console.log(person.toString()); // Person { name: John, age: 30 }
```



#### new实现及问题

new的方法本质上是用一个空的对象去调用构造函数，this指向空的对象，然后就会使得构造函数内部的属性都挂载到实例上

```js
const p = new _()
const p1 = new _(p)
console.log(p1 === p) // true

const p = objFactory(_)
const p1 = objFactory(_, p)
console.log(p1 === p) // true

function objFactory () {
	var obj = new Object()
  Constructor = [].shift.call(arguments)
  obj.__proto__ = Constructor.prototype
  const res = Constructor.apply(obj, arguments) // 获取返回值，确保能返回原对象
  return res ? res : obj
}
function _new (className, ...args) {
   const obj = {}
   obj.__proto__ = className.prototype
   const res = className.call(obj, ...args)
   return res ? res : obj
}
```



#### void

 *void* 运算符通常只用于获取 undefined 的原始值，一般使用 *void*(0) （等同于 *void* 0 ）。在上述情况中，也可以使用全局变量 undefined 来代替。