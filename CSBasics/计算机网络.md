### 计算机网络研究的问题？

计算机研究是多台计算机之间进行数据交互问题，基于请求/响应，发请求的是客户端，等待其他程序连接响应的叫做服务器

#### 解决的问题

1. 解决一台主机怎样找到另外一台主机（网络层IP）
   + IP地址分配与转换（主机标识）
     + 为网络中每台主机分配一个IP地址
     + 将内部地址转化成外部IP地址（NAT/NAPT）
   + 选择最佳路由
     + IGP内部网关协议，EGP外部网关协议
     + RIP路由协议（基于距离向量），OSPF开放式最短路径优先（基于链路状态）
   + 网络拥塞控制
     + 慢启动和拥塞避免
     + 窗口控制
     + 流量控制
     + 拥塞检测与反馈
   + 数据包分组和重组
     + 将数据分成适合的大小（提高传输高速率）
2. 找到主机之后如何进行可靠的数据传输（传输层TCP/UDP协议）
   + TCP 面向连接的可靠传输
     + 三次握手/四次握手
     + 网页访问/文件传输/邮件发送
   + UDP 面向无连接的不可靠传输
     + 不重传/效率高
     + 语音通话/视频通话/网络直播
   + 如何安全的传输？
     + 添加SSL/TSL层
       + 对称加密/非对称加密/哈希算法
       + 信息加密/身份认证/数据完整性
       + TSL 四次握手
3. 传输怎样的数据？提供什么样的服务？（如HTTP、FTP、SMTP协议）
   + 请求与响应
   + HTTP版本迭代（0.9>1.0>1.1>2.0）

**其他：**将数据封装成帧和如何将二进制数据进行传输的事情就是数据链路层和物理层的事情了

**数据名称：**应用层（==消息/报文==），传输层（==数据段==），网络层（==数据包==），链路层（==数据帧==）



### 具体问题

#### NAT与NAPT？

#### 内网穿透？

#### 网络拥塞控制？

1. **慢启动和拥塞控制：**慢启动，即TCP协议在开始发送数据的时候，会逐步增加发送速率，直到出现数据包丢失或者超时等拥塞现象，此时就会出发拥塞避免机制（拥塞避免），降低发送速率，以避免进一步网路拥塞
2. **收发窗口控制：**发送方根据接收方的确认信息调整窗口的大小
3. **流量控制：**根据接收方的处理能力和窗口剩余空间动态调整发送速率
4. **拥塞检测和反馈：**网络设备可以通过测量网络的延迟、丢包率和宽带指数来判断网络是否拥塞

#### TCP控制拥塞的四种算法？

1. **慢开始：**开始发送窗口设置较小，发送较少量的数据就检测网络的拥塞程度，逐步增大窗口，发送更多的数据
2. **拥塞算法：**当网络拥塞的时候，减少网络窗口大小，发送更少的数据
3. **快重传：**要求接收方接受到一个失序报文的时候就立即发出，重复确认
4. **快恢复：**当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半

#### TCP慢启动原理？

最初的TCP在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。

因此，现在的TCP协议规定，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段）；然后触发**拥塞避免机制**，调整发送速率，以避免网络拥塞

#### TCP/UDP协议的区别？

1. TCP面向连接的，数据传输可靠；UDP面向无连接，数据传输不可靠
2. TCP仅支持点对点通信；UDP支持一对一、一对多、多对一和多对多
3. TCP面向字节流（数据传输以字节为单位、一个数据包拆分成若干组）；UDP面向报文的（一个报文一次发完）
4. TCP首部开销（20字节）比UDP首部开销（8个字节）更大
5. TCP耗时；UDP速度快

#### TCP的三次握手？

传输层的TCP协议要建立可靠的连接必须经过三次握手，是确认客户端和服务器都发送和接收正常的过程

1. 客户端将**SYN设置为1**(表示自己要建立TCP连接)，随机产生一个**初始序列号seq**发给服务器，客户端进行syn_sent（**客户端发送SYN**-客户端不确认任何正常，服务器确认对方发送正常，自己接收正常）
2. 服务器收到客户端的SYN之后，将自己的**SYN设置为1，ACK设置为1**，ack number设置为seq+1，然后随机生成自己初始序列号seq，发送给客户端，并进入syn_revd状态（**服务端返回SYN，ACK**-客户端确认自己发送正常，接收正常，确认服务器也能正常接收和发送）
3. 客户端检查ack number是否为seq+1，**ACK是否为1，如果正确将自己的ACK设置为1**，将ack number设置为服务器序列号seq+1，发送给服务器，进入建立状态，服务器收到确认之后也进入建立状态，三次握手完成（**客户端发送ACK**-服务器确认客户端能正常接收，第一次也确认了能正常发送，同时也确认了自己能正常发送，能正常接收）

如果没有第三次客户端的确认，服务器确认之后会认为连接已经建立，但客户端却没有收到或不理会，导致服务器一直等待客户端消息；三次已经能够保证连接正常了，四次会降低传输效率

**序列号（Sequence Number）**：TCP协议通过**序列号来标识数据流中的每一个字节**。在三次握手的第一次握手中，客户端会随机生成一个初始的序列号（SYN码），并在报文段中发送给服务器端。

**确认序列号（Acknowledgement Number）**：**确认序列号是在TCP连接中用来确认接收到对方数据的序列号**。在三次握手的第二次握手中，服务器端会回复一个确认序列号（ACK码），表示它已经接收到了客户端发送的SYN码，并且客户端的序列号+1表示下一次数据发送的序列号。

#### TCP的四次挥手？

1. 客户端将**FIN标识为设置为1**，发送一个序列号给服务器；告诉服务器自己数据传输完了
2. 服务器收到FIN之后，**发送ACK=1**，进入close_wait状态；服务器知道客户端没有要发的数据了，但是仍然可以接收服务器发来的数据，服务器也可以继续接收之前没有接收完发送的数据
3. 服务器将**FIN设置为1**，发送一序列号给客户端，进入last_ack；告诉客户端自己数据已经接收完毕，要关闭连接了
4. 客户端收到服务端关闭连接的消息，说你关闭吧

#### TCP标志位？

1. **SYN标志位**：用于表示一个**连接请求**。在三次握手的第一次握手中，客户端会向服务器端发送一个带有SYN标志位的TCP报文段，表示它请求建立一个连接。
2. **ACK标志位**：用于表示一个**确认响应**。在三次握手的第二次握手中，服务器端会向客户端发送一个带有ACK标志位的TCP报文段，表示它已经接收到了客户端的请求，并准备好建立连接。
3. **FIN标志位**：用于表示一个**连接的结束**。在三次握手的第三次握手中，客户端向服务器端发送一个带有FIN标志位的TCP报文段，表示它已经完成了数据传输，并且请求关闭连接。
4. **RST复位标志：**表示TCP连接是否需要**复位**。当该标志位被设置时，表示当前TCP连接出现了严重错误，需要立即关闭。
5. **PSH推送标志：**表示TCP包中是否包含**推送数据**。当该标志位被设置时，表示接收方应该立即将数据交给应用层处理，而不是等到缓存区被填满之后再交给应用层。
6. **URG紧急标志：**表示TCP包中是否包含**紧急数据**。当该标志位被设置时，TCP包中的紧急数据将被优先处理。

#### 当 TCP 客户端和服务端同时发出断开请求时？

客户端和服务端都收到了对方的断开请求：在这种情况下，TCP 连接会被正常关闭，客户端和服务端都会进入 CLOSED 状态。

1. **客户端先收到服务端的断开请求：**客户端会发送一个 ACK 报文确认服务端的请求，然后进入 TIME_WAIT 状态等待一段时间，以确保服务端已经接收到了 ACK 报文。在这个等待期间，客户端可以处理可能尚未到达的服务端数据，并且还可以重新发送丢失的数据，以确保它们得到正确的传输。等待时间过后，客户端会进入 CLOSED 状态。
2. **服务端先收到客户端的断开请求：**服务端会发送一个 ACK 报文确认客户端的请求，然后关闭连接。在这种情况下，客户端仍然可以向服务端发送数据，但是服务端将不会回复，因为连接已经被关闭。

[服务端主动关闭](https://juejin.cn/post/6844904088501485581)

#### TSL四次握手？

https是建立在tcp链接之后，进行tls握手协议，完成握手之后；整个过程可以理解为客户端和服务器互相发送数字证书验证身份，之后协商密钥，然后进行通信。

涉及到的相关技术：

+ 对称加密/非对称加密/哈希算法
+ 信息加密/身份认证/数据完整性

**https=http+tls，tls的四次握手：**

1. 客户端发送==请求-协商加密协议、版本和算法==

2. 服务器响应请求，返回协商的加密协议、版本和算法，==并返回服务器的数字证书（+公钥）==

3. 客户端利用公钥==验证服务器数字证书==，并将自己的证书返回给服务器

4. 服务器验证客户端身份，开始准备协商密钥
   + 客户端给服务器发送随机数A（用服务器公钥加密）
   + 服务器给客户端发送随机数B（用客户端公钥加密）
   + 协商出密钥key=hash(A,B)
   + 结束握手，开始加密通信

#### 什么是套接字？

两个应用程序通过双向通信实现数据交换，双向链路中一端称为一个套接字，一个套接字由一个**IP地址**和一个**端口号**确定；所谓的套接字就是长连接，客户端与服务器一旦进行连接就不会随意主动断开（属于应用层与传输层中间抽象层）

**通讯过程**

1. **基于TCP：**服务器初始化Socket，绑定端口，对端口进行监听，调用accept阻塞，等待客户端连接。客户端初始化一个Socket，发起与服务器的连接请求，connect成功之后连接就建立了
2. **基于UDP：**客户端只管发送，服务端接受不接受到就不管

#### HTTP的请求状态码？

1xx：指示信息-请求已经接收，正在处理

2xx：成功-请求成功被接收处理

3xx：重定向

4xx：客户端错误

5xx：服务端错误

**常见状态码：**

**200** OK 表示成功

303 重定向，重定向其他页面

304 资源并未修改，可以直接使用本地缓存

404 找不到页面（页面被删除或者其他）

500 服务端错误

#### HTTP发展历史？

1. http 0.9 

   最初的版本，只有一个get命令，不支持请求头和响应头

2. http 1.0

   添加了get、post、head和put

   支持请求头、响应头、状态吗和响应的格式等等

   性能差：原因是每次请求都要重新建立tcp连接，没有复用tcp连接机制，导致网络的延迟和资源浪费

3. http 1.1

   ==持久连接：==多个请求共享一个tcp连接

   流水化：可以发出多个请求，无需等待每个请求的响应

   ==分块传输：==将大的http包分块

4. http 2.0

   ==二进制：==减少了协议头大小和解析时间

   ==多路复用：==一个TCP连接上同时发送多个请求和响应，提高网络性能和效率

   流量控制：每个请求和响应都被分成多个带有编号的数据流（构建窗口）

#### 请求头与响应头？

1. 建立TCP连接（3次握手）
2. 客户端向服务器发送请求行（**请求方式、请求URL和协议版本**）
3. 客户端向服务器发送请求头（请求服务器主机地址、缓存控制、连接状态、语言、编码方式、压缩方式等）
4. **如果是POST请求**，客户端会继续发送请求体内容；如果是GET请求则没有请求体
5. 服务器接收到请求之后，返回请求行（**版本号和状态码**）
6. 返回请求头（应用程序版本、正文内容长度、语言，编码方式，压缩方式等）
7. 返回请求体（响应内容：html文档、资源、图片等等）
8. 断开TCP连接（四次挥手）

#### 请求行、请求头和请求体分开发送？

1. 请求行中包含请求方式、请求URL和协议版本，是基本的请求信息，不需要太大，单独出来发送能够使得服务器快速了解客户端的请求，提高效率
2. 请求头分离出来，可以减少请求体的大小，同时还能帮助服务器了解客户端状态，提高效率
3. 减少请求体大小，降低传输失败情况，提高传输的稳定性

#### GET与POST区别？

1. **请求参数：**get放在URL里面，post放在请求体里面
2. get一般用于向服务器请求数据，post一般向服务器提交数据
3. 一般认为get比post不安全，但从传输角度来说，如果采用http协议都是不安全，要安全就必须采用ssl、tls协议进行加密

#### 跨域问题？

请求的url的协议、域名和端口其中任意一个与目标url不同，造成跨域问题

例如：运行在http://domain-a.com上的js代码使用XMLHttpRequest来请求http://domain-b.com/data.json上的数据

**原因：**浏览器的同源策略，阻止一个域的js脚本域另外一个域的内容进行交互，防止浏览器受到XSS、CSRF等攻击

**解决办法：**[9种跨域解决办法](https://juejin.cn/post/6844903882083024910)

1. nginx反向代理（前端）[正反向代理](https://cloud.tencent.com/developer/article/1418457)
2. jsonp跨域 （利用script标签不受同源策略限制，将请求资源的回调函数添加到url中将服务器数据携带回来，只能用于get请求）
3. 跨域资源共享 （让网页的受限资源能够被其他域名的页面访问的一种机制）

#### Cookie、token和session授权？

**cookie：**在客户端访问服务器之后服务器返回给客户端的一小块保存于本地的数据，它会在客户端浏览器下一次请求服务器的时候被携带到服务器中，==用于服务器对客户端的身份识别==，浏览器自动添加；**但是cookie采用的明文形式，不安全！**（状态数据保存在浏览器，像服务器发送请求的时候携带到服务器）

**session：**记录客户端与服务器之间会话状态的机制；session是基于cookie实现的，session存储于服务器中，sessionID存储于客户端的cookie中（将浏览器状态信息放在浏览器，**服务器只给浏览器生成一个sessionID，当浏览器再次访问的时候携带sessionID**，服务器就可以识别该客户端，存在某个服务器出现负载过重必须得将客户端数据复制到空闲服务器上的问题-可采用分布式存储）

**Token：**客户端会频繁的向服务器请求资源，需要用户名和密码验证；Token是服务器为客户端生成的一段字符串令牌，当第一次客户端访问服务器，服务器为客户端生成一个Token（保存并对用户状态进行了加密，然后将token放在cookie中），下次访问直接验证Token，不需要频繁从数据库中验证用户名和密码，减轻了服务器的压力

**JWT：**当前最流行的JWT-json web token，开发者手动添加；token需要**服务器从数据库中进行查询**，jwt直接**密钥校验**对比

在CSRF攻击中，攻击者利用用户已登录的身份，在用户不知情的情况下，向Web应用程序发起恶意请求。通常情况下，攻击者无法获得用户的Token值，因此Web应用程序可以在处理请求时验证Token值是否合法，如果Token值不合法，则可以拒绝请求（服务器公钥加密token，中间人无法获取）

XSS攻击，Web应用程序使用了Token机制，那么攻击者无法获取到Token值，也就无法在恶意脚本中伪造合法的请求

[cookie、session和token](https://www.bilibili.com/video/BV1b14y1J7Yv/?spm_id_from=333.788.recommend_more_video.2&vd_source=084728306193898208d80f40ece2975b)

#### 常见浏览器攻击？

浏览器攻击是指利用浏览器漏洞对用户进行攻击的一种方式，常见的浏览器攻击方式：

1. **跨站脚本攻击（XSS-*Cross-Site Scripting*）**：攻击者利用网站漏洞，向客户端网页中注入恶意脚本，当用户访问这个页面时，恶意脚本会被执行，攻击者可以通过这种方式窃取用户的敏感信息。
   + 从客户端和服务端考虑预防攻击
2. **跨站请求伪造（CSRF攻击-Cross-Site Request Forgery）：**攻击者通过某种方式让用户在登录状态下访问一个恶意网页，这个网页会向用户正在访问的网站发送请求，从而实现攻击目的。
   + 为每个回话生成随机的CSRF令牌(同步令牌或者反CSRF令牌)——为客户端每个表单生成令牌来证明是合法客户端提交的表单
   + 严格保持同源策略
   + 设置httpOnly字段,严格限制cookie的读取
   + content-type验证是否来自合法客户端
3. **点击劫持攻击：**攻击者利用透明iframe将一个合法的网页覆盖在一个恶意网页上，当用户在看到的合法网页上进行点击操作时，实际上是在进行恶意网页上的操作，攻击者可以通过这种方式控制用户的操作。
4. **代码注入攻击：**攻击者通过输入恶意代码，对浏览器或服务器进行攻击，这种攻击方式常常被用于窃取用户的敏感信息。
5. **URL欺骗攻击：**攻击者将一个看似正常的URL欺骗用户点击，实际上却指向一个恶意网站，从而实现攻击目的。

#### 如何保证数据能够完整、正确和可靠的传输？

1. **使用校验和：**发送方在数据发送之前添加校验字段，接收方接受后进行校验对比
2. **使用序列号：**对接收到的数据进行重排，确保数据完整性
3. **确认应答机制：**接收方在收到消息并确认无误后发送确认消息
4. **重传机制：**对错误或者丢失的包进行重传
5. **加密技术：**对传输的数据进行加密，确保数据安全可靠
6. **数字证书：**对发送方数据进行签名，接收方验证发送方是否属于可靠机构

#### 什么是数字签名？

用于验证消息完整性、真实性和不可否认性的技术；私钥用于加密，公钥用于验证

1. 发送方生成私钥和公钥
2. 用私钥进行数据加密
3. 将加密后的数据和公钥一同发送给接受方
4. 接收方验证签名

#### ARP协议

地址解析协议，**根据IP地址获取MAC物理地址的一个TCP/IP协议**；主机发送消息时将包含目标IP地址的ARP请求广播到局域网的所有主机，并接收返回信息，确定目标的MAC地址

#### 数据链路层解决什么问题

1、将数据组合成数据块，封装成帧

2、差错控制

3、流量控制

4、链路控制

5、MAC寻址

6、区分数据和控制信息

7、透明传输

#### 物理层解决什么问题

1. 数据在媒介上的传输问题

2. 如何确保比特流正确的进行端到端传输（可靠性问题）