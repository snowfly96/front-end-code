### 常见设计模式

设计模式（Design Pattern）是一种被广泛接受的**代码设计经验的总结和归纳**，它提供了一套可重复使用的解决方案，用于解决在软件设计过程中所遇到的一些**常见问题**，从而提高代码的**可读性、可维护性和可扩展性**。

设计模式通常分为三类：创建型模式、结构型模式和行为型模式。下面分别介绍一下这三类模式以及一些常见的设计模式：

[设计模式总结一](https://refactoringguru.cn/design-patterns/bridge) 【重要】

[设计模式之菜鸟](https://www.runoob.com/design-pattern/bridge-pattern.html)

[设计模式之掘金](https://juejin.cn/collection/7248828229914312759)

#### 创建型模式

创建型模式关注如何实例化对象。常见的创建型模式有：

- 工厂模式（Factory Pattern）

  > 工厂模式是一种常用的对象创建设计模式，通过定义一个工厂接口来创建产品对象，而不是直接new产品对象

- 单例模式（Singleton Pattern）

  > 单例模式保证每个类只有一个实例，并提供全局访问点来访问这个实例
  >
  > 1. 全局唯一的系统配置
  > 2. 全局的日志对象

- 建造者模式（Builder Pattern）

  > 创建一个构造器来构造复杂的对象

- 原型模式（Prototype Pattern）

  > 不需要显式的通过构造函数利用现有的对象来构建新的对象

#### 结构型模式

结构型模式关注如何组合类和对象以形成更大的结构。常见的结构型模式有：

- 适配器模式（Adapter Pattern）

  > 将一个类的接口转化为另一个客户希望的接口
  >
  > 创建一个新的适配器类来继承原有的类实现新的接口
  >
  > 例如：==构建一个适配器将返回的是数据格式进行统一的处理==
  >
  > 1. 项目中页面有：下拉框、列表和多选框等，构建一个适配器将后端传回来的数据通过一个适配器进行统一处理得到想要的数据格式

- 桥接模式（Bridge Pattern）

  > 抽象部分与实现部分分离，例如GUI界面（抽象）和操作系统API（实现）

- 组合模式（Composite Pattern）

  > 同一个维度的对象像树一样组合在一起

- 装饰器模式（Decorator Pattern）

  > 在不修改对象自身的基础上，通过对其进行包装（装饰）来拓展其行为和功能的目的

- 外观模式（Facade Pattern）

  > 为复杂系统提供简单的接口

- 享元模式（Flyweight Pattern）

  > 通过共享对象来支持大量的细粒度对象，享元模式对象中分为内部状态和外部状态，内部对象独立于对象的上下文环境，可以被全局共享，外部对象取决于对象的上下文环境，无法共享

- 代理模式（Proxy Pattern）

  > 在访问对象时引入一定程度的间接性，以便更好地控制对对象的访问
  >
  > 1. 远程代理：在另外一个主机上创建该对象的本地代理
  > 2. 虚拟代理：充当对象的占位符，使用时再创建，例如浏览器图片加载
  > 3. 安全代理：安全代理用于控制访问资源的权限，例如对敏感对象采用代理方式

#### 行为型模式

行为型模式关注对象之间的通信。常见的行为型模式有：

- 责任链模式（Chain of Responsibility Pattern）

  > 允许请求沿着责任链发送

- 命令模式（Command Pattern）

  > 将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

- 解释器模式（Interpreter Pattern）

  > 定义中语言文法的表示，并定义一个解释器，用来解释这种语言的句子

- 迭代器模式（Iterator Pattern）

  > 提供一个简单的方法来访问一个聚合的对象（例如一个列表或者集合）的所有元素，无需了解底层的细节
  >
  > 1. 聚合对象：提供创建迭代器的接口（列表、集合等）
  > 2. 迭代器：定义了访问和遍历聚合对象中元素的接口

- 中介者模式（Mediator Pattern）

- 备忘录模式（Memento Pattern）

- 观察者模式（Observer Pattern）

  > 通过定义一对多的依赖关系，让多个观察对象同时监听某一个对象主题，当对象主题发生变的时候，所有观察者都会收到通知和更新

- 状态模式（State Pattern）

- 策略模式（Strategy Pattern）

  > 策略+上下文对象

- 模板方法模式（Template Method Pattern）

- 访问者模式（Visitor Pattern）

  > 主要目的是将算法和数据结构分离，即不改变数据结构的前提下，定义作用于这些结构上的新操作



### 前端架构设计模式（软件架构设计模式）

> 常见的前端架构设计模式有：MVC、MVP和MVVM等 
>
> 相同部分：MV
>
> 不同部分：C（controllrt）、P（presenter）和VM（view-model）

<img src="/Users/snowfly96/Documents/GitHub/front-end-code/CSBasics/assets/MV.png" alt="MV" style="zoom:50%;" />

[小红书前端开发常用五种架构模式](https://www.xiaohongshu.com/explore/640aa113000000002702b8b6?app_platform=android&app_version=7.82.0&share_from_user_hidden=true&type=normal&xhsshare=WeixinSession&appuid=615334060000000002024321&apptime=1681173149)

#### MVC

> 软件系统分为三部分：模型、视图和控制器，**所用通信是单向的**

**模型（Model）：**封装与应用程序的逻辑业务，模型数据变化，则通知View变化

**视图（View）：**视图用于数据展示和响应用户的操作，将指令传给Controller

**控制器（Controller）：**模型和视图之间的纽带，接收视图传来的用户事件并传递给模型，模型完成逻辑后操作View更新

**优点**

1. 代码结构清晰，易于维护
2. 实现前后端分离，提高开发效率

**缺点**

1. 视图和模型的依赖关系比较紧密，不利于代码重用
2. 逻辑分散到了多个控制器中，代码复杂度高
3. 视图和控制器的耦合度高，不利于单元测试

#### MVP

> 是对MVC的改良，在view中不直接使用model，model和view之间的通信是通过presenter进行的
>
> **数据通信是双向的**

**模型（Model）：**依旧处理与业务相关的数据和对应方法

**视图（View）：**负责显示和通知presenter

**中间人（Presenter）：**作为view和model的中间人（纽带）

**优化**

1. 视图和模型解藕，提高了代码的可测试性

**缺点**

1. presenter负担过重
2. 视图与presenter之间耦合度过高，代码可读性变差

#### MVVM模式

> 采取双向绑定，view变动直接自动的反应在viewmodel上，反之亦然

**模型（Model）：**依旧处理与业务相关的数据和对应方法

**视图（View）：**负责显示并将视图变动直接更新在view-model上

**VM（ViewModel）：**作为将模型的更新直接反映到view上面

**优点**

1. 前端开发效率高
2. 数据双向绑定，数据与视图自动同步，开发效率高

**缺点**

1. 大量的数据检测变化，影响性能