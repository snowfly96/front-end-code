<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button>测试1</button>
    <button>测试2</button>
    <button>测试3</button>
</body>
<script>
    // btn与i没对应的文图
    /*     var btns=document.getElementsByTagName("button");
        for(var i=0,length=btns.length;i<length;i++){
            var btn=btns[i]
            btn.onclick=function(){
                alert(`第${i+1}按钮`)
            }
        } */
    // 提前保存i
    /*     var btns=document.getElementsByTagName("button");
        for(var i=0,length=btns.length;i<length;i++){
            var btn=btns[i]
            btn.index=i
            btn.onclick=function(){
                alert(`第${this.index+1}按钮`)
            }
        }    */

    // 闭包实现循环遍历加监听
    /*     var btns=document.getElementsByTagName("button");
        for(var i=0,length=btns.length;i<length;i++){
            (function(i){
                // i是自己函数闭包内作用域下的
                var btn=btns[i]
                btn.onclick=function(){
                    alert(`第${i+1}按钮`)
                }
            })(i)
        }  */


    /* 
    如何产生闭包？// 执行函数定义就行就能形成闭包
        * 当一个嵌套的内部（子）函数引用的外部（父）函数的变量
        * 通过chrome调试工具查看
        * 理解一：闭包是嵌套的内部函数
        * 理解二：包含被引用变量（函数）的对象
        * 注意：闭包存在嵌套的内部函数中
     */
    function fn1 () {
        var a = 2
        function fn2 () {
            console.log(a)
        }
        fn2()
    }
    fn1()

    // 是内部变量在函数执行完后，仍然存在内存中（延长生命周期）
    // 是的函数外部可以操作函数内部变量

    // 1. 将函数作为另外一个函数的返回值
    function fn3 () {
        var a = 2
        function fn4 () {
            a++
            console.log(a)
        }
        return fn4
    }
    var f4 = fn3() // f4一直存在全局作用域下，指向的fn3闭包也就一直存在
    f4() // 3 进入执行17行
    f4() // 4 
    // 一共产生了一个闭包

    // 2. 将函数作为实际参数传递给另外一个函数调用

    function fn5 (msg, callback) {
        setTimeout(() => {
            callback(msg)
        }, 1000)
    }
    // 1. 函数执行完之后，内部的局部变量是否还存在？一般不存在，除非有闭包
    // 2. 函数外部的能直接访问外部变量么？不能，可以使用闭包进行操作

    // 闭包的生命周期
    /* 
        * 产生：嵌套内部函数定义执行完毕之后就产生了（不是在调用的时候产生）
        * 死亡：嵌套的内部函数称为垃圾对象的时候 f=null可以让其死亡
     */

    // 闭包的应用
    /* 
        定义JS模块
            * 具有特定功能的模块
            * 将所有的数据和功能封装在一个函数内部
            * 向外暴露一些特定的对象和函数
            * 模块的使用者，只需要通过模块暴露的对西那个调用方法来实现对应的功能
     */
    function myModule () {
        var msg = "Snow"
        function doSomething () {
            console.log("ds:" + msg.toUpperCase())
        }
        function doOtherthing () {
            console.log("do:" + msg.toLowerCase())
        }
        return {
            doSomething: doSomething,
            doOtherthing: doOtherthing
        }
    }
    var mm = myModule()
    mm.doSomething()
    mm.doOtherthing()

        // 匿名函数暴露
        ; (function () {
            var msg = "Snow"
            function doSomething () {
                console.log("ds2:" + msg.toUpperCase())
            }
            function doOtherthing () {
                console.log("do2:" + msg.toLowerCase())
            }
            window.myModule2 = {
                doSomething: doSomething,
                doOtherthing: doOtherthing
            }
        })()

    myModule2.doSomething()
    myModule2.doOtherthing()

    // 闭包的缺点
    /* 
        * 函数执行完之后，函数的局部变量没有释放，占用内存时间会变长
        * 容易造成内存泄漏
    解决：
        * 能不用就不用
        * 及时释放
     */
    function fn7 () {
        var a = new Array[10000]
        function fn8 () {
            console.log(a.length)
        }
        return fn2
    }
    var f7 = fn7()
    f7()
    // 及时释放 f7=null
</script>

</html>