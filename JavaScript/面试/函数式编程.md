### :pen: 函数式编程

函数式编程是一种编程范式，对应的编程范式还有命令式编程和逻辑式编程

**命令式编程**是面向计算机硬件的抽象，有变量（存储单元）、赋值语句（获取和存储指令）、表达式（运算和引用）和控制语句（跳转指令），**命令式编程就是一个冯诺依曼指令序列**；

**命令式编程**关心是的解决问题的步骤，利用已有**数据和指令按步骤解决现实问**题

**函数式编程**是面向数学的抽象，基于$\lambda$演算（图灵完全）-表达式求值

**函数式编程**关心的是数据背后的逻辑关系，$\lambda$演算本身能够构造出数据

[参考知乎编程范式](https://www.zhihu.com/question/28292740)



##### 引用透明

如果一个函数输入相同的参数始终返回同一个结果，那么这个函数就是引用透明的

##### 没有副作用

**[有副作用](https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))**则是当调用函数时候，除了返回可能的函数值之外，还对主调用的函数产生了附加影响。例如修改全局变量、修改参数、改变外部存储信息等

##### 纯函数

函数与外界数据交换的唯一渠道只有参数和返回值，参数从外部接受输入，通过返回值输出，像一根管道



#### [案例](https://juejin.cn/post/6844903936378273799)

需求：将一个字符串变数组成一个对象数组

```javascript
['snow','tom','jack']
[{name:'snow'},{name:'tom'},{name:'jack'}]
```

**命令式编程**

1. 定义一个新的数组
2. 做一个循环
3. 将字符串数组中每个字符串编程一个对象
4. 将每个对象方法新数组内
5. 返回结果

中间会产生一大堆变量，需要从读到尾才能明白具体做了什么

**函数式编程**

将一个字符串变数组成一个对象数组问题进行拆解

[String]->[Object]拆解为String->Object转化

1. 定义一个函数str2Obj()
2. 定一个map()
3. 则strArr2ObjArr=map(str2Obj)
4. 结果strArr2ObjArr(['snow','tom','jack'])

函数编程流水线：数据可以不断从一个函数的输出流入另一个函数的输入

####  函数编程特点

**函数是“一等公民”**

函数编程基本上都在操作函数，函数和其他数据类型地位一样，可以复制给变量也可以作为参数，作为返回值

**声明式编程**

声明我们需要做什么，不是事怎么去做，代码可读性高

sql也是声明式的，无关心select语句怎么实现，数据库有自己的实现和优化方法

react也是声明式的，只需要描述ui状态，状态怎么变化react会帮助程序员去实现

**惰性执行**

惰性执行指的是函数只在需要的时候执行，不产生无意义的中间变量

**无状态和数据不可变**

函数编程的核心：

1. 数据不可变：要求所有的数据是不可变的，如果要修改一个对象，那么应该创建一个新的对象来进行修改
2. 无状态：强调的是无论什么时候运行都是像第一次运行一样，给相同输入出来相同的结果

**没有副作用**

常见的函数副作用就是修改外部变量，由于js的对象传入都是引用地址，所以这个“漏洞”让我们随意修改对象

**纯函数**

1. 不依赖外部状态（无状态）：函数运行结果不依赖全局变量，this指针和io操作等
2. 没有副作用（数据不变）：不修改全局变量，不修改参数

纯函数的意义：

	1. 便于测试和优化
	1. 可缓存性：提前存储函数执行结果，不需要计算直接取值
	1. 更少debug，不存在不明指向的this，不存在全局变量的引用，不存在对参数的修改



#### 函数编程应用

两大应用：柯里化操作和函数组合

柯里化是流水线上的加工站，函数组合是流水线（多个加工站组成）

**柯里化和部分函数区别**

部分函数强调的是固定一些参数，返回更小元的函数

柯里化强调的是生成单元函数

```javascript
// 柯里化
f(a,b,c) → f(a)(b)(c)
// 部分函数调用
f(a,b,c) → f(a)(b,c) / f(a,b)(c)
```

**函数组合**

将多个函数组合成一个函数

```javascript
const compose = (f, g) => x => f(g(x))

const f = x => x + 1;
const g = x => x * 2;
const fg = compose(f, g);
fg(1) //3
```

函数组合面向对象写法：

```javascript
arr.reverse()
  .head()
  .toUpperCase()
  .log()
```

命令式写法：

```javascript
log(toUpperCase(head(reverse(arr))))
```

函数式编程写法：

```javascript
const upperLastItem = compose(log, toUpperCase, head, reverse);
```

函数式编程的显然时候代码变得简单，可读性更强

#### 参考

[简明 JavaScript 函数式编程——入门篇](https://juejin.cn/post/6844903936378273799)













